---
title: "Recipe for analysis of the dual-use data"
author: "Heidi Seibold"
date: "April 25, 2017"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r echo=FALSE}
# set the knitr option so that no chunks produce messages 
# silently load the learnr library so that the file will run as a shiny document
knitr::opts_chunk$set(message = FALSE)
library("learnr")
```

TODO:

- Beginning of the recipe:
    + End result
    + ingredients (packages, etc.)
- Comment the code
- Tell a story
- Easy explanations
- This is what we will do, this is what we are doing and this is what we've done

----

Dual-use goods are goods that can be used for civil and military purposes. 
In Switzerland, these goods are governed with a special legislation – 
unlike in other countries, where they are looked at as conventional arms exports. 

The state secretariat for economic affairs (SECO) in Switzerland decides which
dual-use goods may be exported and also 
[provides the data](https://www.seco.admin.ch/seco/de/home/Aussenwirtschaftspolitik_Wirtschaftliche_Zusammenarbeit/Wirtschaftsbeziehungen/exportkontrollen-und-sanktionen/industrieprodukte--dual-use--und-besondere-militaerische-gueter/statistik/2015.html) 
after each quarter.

The [SRF data](srf.ch/data) team - the data journalism team of Swiss Radio and TV -
has been repeatedly analysing this data in the past years. 
The reasons for using R for this task are various:

- R can read in Excel data (SECO provides the data in xlsx format)
- R allows for automation of data cleaning and analyses that have to be repeated
- R can export data to csv so it can be used in other programs (e.g. Excel)
- R produces good graphics and allows for individualised themes
- Reproducible documents (e.g. HTML or PDF) can be created with R, while changes  and updates can be included without major effort

You can find the entire analysis on the [SRF data GitHub repository](https://github.com/srfdata/2017-01-dual-use)
and the article from January 2017 on the 
[SRF website](http://www.srf.ch/news/schweiz/schweiz-bewilligt-millionendeal-mit-dem-irak).



# Ask

At the beginning of 2017 SRF data analyst Timo Grossenbacher wanted to answer the 
question   
**Which dual-use goods were exported to which countries in each quarter of the 
years 2012 to 2016?**

Having cleaned and visualised the data he realised that suddenly in 2016 Switzerland started exporting 
dual-use goods to Irak after not having done so in the years prior. This became the story
in the January 2017 [article](http://www.srf.ch/news/schweiz/schweiz-bewilligt-millionendeal-mit-dem-irak) .

We want to answer the same question and in order to have a clean project, create
a new folder on your computer in which you will store all details on this project.
We propose the following:

- Create a folder called `switzerland-dual-use`
- Within this folder create another two more folders called `data_raw` and `data_clean`

```{}
└── switzerland-dual-use
    ├── data_clean
    └── data_raw
```


# Find 

The data can be found (in German) on the [SECO website](https://www.seco.admin.ch/seco/de/home/Aussenwirtschaftspolitik_Wirtschaftliche_Zusammenarbeit/Wirtschaftsbeziehungen/exportkontrollen-und-sanktionen/industrieprodukte--dual-use--und-besondere-militaerische-gueter/statistik/2015.html). SRF also keeps the data available in their [GitHub repo](https://github.com/srfdata/2017-01-dual-use/tree/master/analysis/input).



# Get

The data can be downloaded by clicking on the data links on the 
[SECO website](https://www.seco.admin.ch/seco/de/home/Aussenwirtschaftspolitik_Wirtschaftliche_Zusammenarbeit/Wirtschaftsbeziehungen/exportkontrollen-und-sanktionen/industrieprodukte--dual-use--und-besondere-militaerische-gueter/statistik/2015.html). Get the data files and store them in the folder `data_raw`.

Yor file structure should now look like this,
```{}
└── switzerland-dual-use
    ├── data_clean
    └── data_raw
        ├── 1_Quartal_2016_Bewilligungen.xlsx
        ├── 2. Quartal 2016 Erteilte Ausfuhrbewilligungen.xlsx
        ├── 3. Quartal 2016 Erteilte Ausfuhrbewilligungen.xlsx
        ├── 4. Quartal 2016 Erteilte Ausfuhrbewilligungen.xlsx
        ├── Stat_IP_2015_Bewilligungen.xlsx
        ├── Statistik Dual-Use 2014 Elic.xlsx
        ├── Statistik Dual-Use Jan. 2012 - Sep. 2014 Tracker.xlsx
        └── Statistik ML 2005-2013.xlsx
```
i.e. you should have the dual-use Excel files corresponding to years 2012 to 2016.

Let's try reading in the data of first two quarters of 2016:

1. Open your R editor (e.g. RStudio) 
2. Set your working directory to the `switzerland-dual-use` directory. 
To do this first enter 
```{r, eval=FALSE}
getwd()
```
in the console. This will show your current working directory.
E.g. for me it shows `[1] "/home/heidi/Documents"`. Next use `setwd()` to change 
to the correct diretory. For me it is `/home/heidi/Documents/switzerland-dual-use` 
and so I have to type
```{r, eval=FALSE}
setwd("switzerland-dual-use")
```
or equivalently 
```{r, eval=FALSE}
setwd("/home/heidi/Documents/switzerland-dual-use")
```

To read Excel data into R, we need a specialised R package, which is called
`readxl`. To install the package run
```{r, eval=FALSE}
install.packages("readxl")
```
To load the package run
```{r}
library("readxl") 
```
Now we can read the data of the four quarters of 2016:
```{r}
elic_2016_q1_raw <- read_excel(path = "data_raw/1_Quartal_2016_Bewilligungen.xlsx")
elic_2016_q2_raw <- read_excel(path = "data_raw/2. Quartal 2016 Erteilte Ausfuhrbewilligungen.xlsx")
elic_2016_q3_raw <- read_excel(path = "data_raw/3. Quartal 2016 Erteilte Ausfuhrbewilligungen.xlsx")
elic_2016_q4_raw <- read_excel(path = "data_raw/4. Quartal 2016 Erteilte Ausfuhrbewilligungen.xlsx")
```

# Verify
To check whether reading in worked and the data is what we wanted, there are a couple of useful commands in R. Let's now first work with `elic_2016_q1_raw`:

- `names()` shows the column names of the data frame
```{r}
names(elic_2016_q1_raw)
```
- `head()` shows the first few rows of the data frame
```{r}
head(elic_2016_q1_raw)
```
- `tail()` shows the last few rows of the data frame
```{r}
tail(elic_2016_q1_raw)
```
- `summary()` shows a summary of the data. For numeric variables such as the price (`Wert [CHF]`) this function 
shows the [five number summary](https://en.wikipedia.org/wiki/Five-number_summary) and the mean (average).  For character variables such as receiving country (`Bestimmungsland`) the function shows the variable's length and informs that it is of the character class and mode.
```{r}
summary(elic_2016_q1_raw)
```
- `str()` shows the type of each variable (here `num` for numeric and `chr` for character) and the
first few values
```{r}
str(elic_2016_q1_raw)
```


# Clean

In this section we will need the `dplyr` package
```{r}
library("dplyr")   ## if not available install by typing install.packages("dplyr")
```


As a first step we want to combine the four 2016 data sets. You might have already
realised that the first data set has one collumn that is just `NA`. `NA` is the 
missing value indicator in R. So basically this collumn does not contain any 
information. Let's see what happens to this collumn if we combine the four 
data sets using function `bind_rows()`.

```{r}
names(elic_2016_q1_raw)
names(elic_2016_q2_raw)

elic_2016_1 <- bind_rows("16/01" = elic_2016_q1_raw, 
                         "16/02" = elic_2016_q2_raw, 
                         "16/03" = elic_2016_q3_raw, 
                         "16/04" = elic_2016_q4_raw, 
                         .id = "Quartal")

names(elic_2016_1)
str(elic_2016_1)
```
`bind_rows()` keeps all collumns in all data sets and fills them with `NA` for the 
data sets that do not contain this collumn. Also it created a new collumn called
`Quartal`. It did that because we told it that the `.id` collumn is `Quartal` and
the values for each `Quartal` is given in the quotation marks `"`. 

Now we do not want to keep the collumn with just `NA` values and we want to 
rename a few variables. We can do this with function `select()`:

- To just select a variable, name it (e.g. `Quartal`)
- To select and rename a variable, put `newname = oldname` (e.g. `GN = Geschäftsnummer`)
- For variables with spaces or special symbols, use to show where it starts and ends
  (see e.g. `Wert [CHF]`)
- To select all except one variable, use the minus symbol 
  (e.g. `select(.data = elic_2016_3, -Art)` below)
```{r}
elic_2016_2 <- select(.data = elic_2016_1,
                      GN = Geschäftsnummer, 
                      Quartal, 
                      Land = Bestimmungsland, 
                      Wert = `Wert [CHF]`, 
                      Typ = Güterart, 
                      Signatur = `Exportkontrollnummer [EKN]`, 
                      Art = Richtung)
str(elic_2016_2)
```

We are only interested in exports (variable `Art`, value `"Ausfuhr"`), so we use
`filter()` to select the rows in the data set where this is the case. Before that
we check how many rows contain other values. `elic_2016_2$Art` gives us the variable
we are interested in and functin `table()` creates a table for the frequencies of
the different values. 
```{r}
table(elic_2016_2$Art)
```
The data set after using `filter()` should have 
`r sum(elic_2016_2$Art == "Ausfuhr")` rows.
```{r}
elic_2016_3 <- filter(.data = elic_2016_2, Art == "Ausfuhr")
str(elic_2016_3)
```
Now the collumn `Art` is not needed anymore. Let's unselect it.
```{r}
elic_2016_4 <- select(.data = elic_2016_3, -Art)
str(elic_2016_4)
```

Let's see what the types of goods are in the dataset.
```{r}
unique(elic_2016_4$Typ)
```
It looks like the variable `Typ` needs a bit of cleaning because some values are clearly variants that can be set to the simpler version. We can do that by writing a function.
```{r}
# Here are two 'vectors', the first with the original values and the second with the replacement values

typ_from <- c("Chemikalien CWÜ",
              "Dual Use Güter\r\nDual Use Güter",
              "Chemikalien CWÜ\r\nDual Use Güter",
              "Besondere militärische Güter\r\nBesondere militärische Güter",
              "Chemikalien CWÜ\r\nBesondere militärische Güter",
              "Dual Use Güter\r\nChemikalien CWÜ")
typ_to <- c("Chemikalien",
            "Dual Use Güter",
            "Chemikalien",
            "Besondere militärische Güter",
            "Chemikalien",
            "Dual Use Güter")

# The function, below, has three arguments: the name of the column in the data set where the values are found, and the vectors of original and replacement values. It contains a for-loop that proceeds through each original value, identifying where in the column the value occur, and replacing those values with the corresponding new value. The following lines define the function:
change_charval <- function(x, from, to) {
  
  for(i in 1:length(from)) {
    x[x == from[i]] <- to[i]
  }
  
  return(x)
}

# Now we will call (i.e., run) the function.  We'll assign the cleaned-up values to a new variable, 'Typ', which is not in the data set.
Typ <- change_charval(x = elic_2016_4$Typ, from = typ_from, to = typ_to)

# Now we'll create a new column named 'Typ_raw' to hold the original values.
elic_2016_4$Typ_raw <- elic_2016_4$Typ

# Next we assign the cleaned-up values in 'Typ' to the data set column with the same name, effectively over-writing the original values.
elic_2016_4$Typ <- Typ
```


# Analyse

For this section we'll produce some nice graphics with package `ggplot2`
```{r}
library("ggplot2")
```

### A first plot
Let's try making a first plot, which shows how often Switzerland has exported
to each country. The plus sign below is particular to ggplot and means that an additional graphic element will be specified. When specified in this way, the length of the bars is determined by the number of times that a value occurs in the data. In this case, that means the number of times a country name occurs in the column `Land` in data set `elic_2016_4`.  This is determined by the ggplot aesthetic function, aes(), when specified as it is below, and a call is made to geom_bar().
```{r, fig.height=12, fig.width=7}

ggplot(elic_2016_4, aes(x = Land)) +  
  geom_bar() +                        
  coord_flip()   #this makes the bars horizontal
```
### Order the countries by export volume

Let's sort the destination countries by number of exports they receive. This takes a few steps. First we group the rows by country ('Land'), using group_by(). Then the function `summarize()` computes by country the number of exports, here 'n', actually the number of rows of entries for each country. Here, group_by() is nested within summarize(). Then `order()` identifies the row order of the data based on the number of rows `n` associated with each country.  Then `factor()` helps us define that when plotted, the country levels should be in the specified order. `ggplot()` automatically understands that it should plot the factor levels in this order.

```{r sort_by_number_of_exports}
# This code groups elic_2016_4 by the variable country ('Land'), then uses summarise() to find the number of rows (the entries, i.e. exports) for each country. It assigns these values to the variable 'n'. 
n_land <- summarise(group_by(elic_2016_4, Land), n = NROW(Land))
head(n_land)

# The function order() then gets the order in terms of the value of 'n', and provides an ascending index of the resulting row order
ord <- order(n_land$n)
str(ord)  # the row position of each country, in ascending order by the magnitude of n 
ordered_land <- n_land$Land[ord] # impose the sorted order and store in a variable
head(ordered_land)  #the first six values
tail(ordered_land)  #the last six values

# Now we convert the column 'Land' to the factor variable type, and set the order of the levels (i.e. values) by specifying the ordered vector of country names 'ordered_land'.  This does not change the row order of the data set, but makes the data print and plot in this order when the factor variable is used.
elic_2016_4$Land <- factor(elic_2016_4$Land, levels = ordered_land)
str(elic_2016_4$Land)

```
### Plot the countries in order of export volume
The next plot makes another horizontal bar chart in which the order of the countries is determined by the factor level we specified above.  So the bar length and the country order both depend on the number of rows associated with each country, the first because ggplot counts the number of rows, the second because elic_2016_4$Land is now an ordered factor. 

```{r, fig.height=12, fig.width=7}
ggplot(elic_2016_4, aes(x = Land)) + 
  geom_bar() +
  coord_flip()
```

### Plot the countries in order of export value
The following plot shows the worth of the goods that were exported to each country. Again we want to have the countries in a specific order, but this time the value we use to sort the data is the sum of the monitary value (the variable `Wert`) of exports to each country.  So we re-order the countries based on the summed export value, and assign this order in the `levels =` specification.

```{r} 
wert_land <- summarise(group_by(elic_2016_4, Land), sum = sum(Wert))
# the re-ordering and assignment to a variable are here done in one line
ordered_land <- wert_land$Land[order(wert_land$sum)] 
# then the levels of the factor are assigned
elic_2016_4$Land <- factor(elic_2016_4$Land, levels = ordered_land)
```

The plot is similar, but by writing `stat = "identity"`, the total value of `Wert` is plotted for each country, and these are displayed in the order of value, which we just specified above.

```{r, fig.height=12, fig.width=7}
ggplot(elic_2016_4, aes(x = Land, y = Wert, fill = Typ)) + 
  geom_bar(stat = "identity") +
  coord_flip()
```

But wait, why are there countries listed, that do not seem to have gotten anything
from switzerland? Let's look at those:

```{r}
library('knitr') # kable() in this package will make nice tables

novalue  <- filter(.data = elic_2016_4, Wert == 0) # get only the lines with zero value
kable(summarize(group_by(.data=novalue,Land,Typ),n=n()),format = "html",caption = "Number Exports without Declared Value")
```

### Countries receiving the highest value of exports
Let's look at the 10 countries that had the highest value exports in the data set.

```{r, fig.height=2, fig.width=7}
elic_2016_value <- filter(.data = elic_2016_4, Wert > 0)
elic_2016_value$Land <- droplevels(elic_2016_value$Land)
```
```{r}
elic_2016_4$Land2 <- elic_2016_4$Land
highest10 <- tail(levels(elic_2016_4$Land), 10)
```
All the countries that aren't in the group of 10 will be pooled into "Other countries" by specifying for them all just a single factor level, "Other countries".  This is done by constructing an expression that returns TRUE for the levels of elic_2016_4$Land2 (i.e., the countries) that are in highest10, using %in%, then negating it with '!', the negation operator.
```{r}
head(levels(elic_2016_4$Land2) %in% highest10)
head(!levels(elic_2016_4$Land2) %in% highest10)

levels(elic_2016_4$Land2)[!(levels(elic_2016_4$Land2) %in% highest10)] <- "Other countries"
```
```{r}
wert_typ <- summarise(group_by(elic_2016_4, Typ), sum = sum(Wert))
ordered_typ <- wert_typ$Typ[order(wert_typ$sum)]
elic_2016_4$Typ <- factor(elic_2016_4$Typ, levels = rev(ordered_typ))
```
```{r, fig.width=9}
p_cntry <- ggplot(elic_2016_4, aes(x = Land2, y = Wert, fill = Typ)) + 
  geom_bar(stat = "identity") +  # so tha values in Wert are used for bar length 
  coord_flip() +  # Remember, we have to flip the plot to horizontal bars
  xlab("Land") # There is a lot of flexibility in the labeling of the plots. Here is a start.
p_cntry
```

# Present
One cool thing about using `ggplot2` in a newsroom is that you can have different themes (color and font schemes).

```{r}
p_cntry + theme_minimal()
p_cntry + theme_bw()
```


With the `ggthemes` package you can go even more wild and try themes that are similar to the themes of famous newsrooms...
```{r, fig.width=9}
library("ggthemes")
```

...such as the Economist,...
```{r, fig.width=9}
p_cntry + theme_economist() + scale_fill_economist()
```

...FiveThirtyEight,...
```{r, fig.width=9}
my_palette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00")
p_cntry + theme_fivethirtyeight() + scale_fill_manual(values = my_palette)
```

...or the Wall Street Journal.
```{r, fig.width=9}
p_cntry + theme_wsj() + scale_fill_wsj()
```

And if you want to really badly go back to an ungly 2003 Excel style, you 
can do that too :)
```{r}
p_cntry + theme_excel()
```

Or you take a theme you like and modify it. 
To create a School of Data themed plot, you can use the following colors and
fonts.  Gill Sans MT is used because it should work on both Windows and Mac.
```{r fig.width=9}
scodablue <- "#00AFF0" 
scodagrey <- "#333333"
scodagrey2 <- "#C9C9C9"
scodacol <- c(scodablue, "#CCCC33", "#FF358B", "#59631E", "#29D9C2", "#C9C9C9")
p_cntry + 
  scale_fill_manual(values = scodacol) +
  theme_classic(base_size = 11, base_family = "Gill Sans MT") +
  theme(axis.text = element_text(family = "Gill Sans MT Bold", colour = scodagrey),  
        panel.grid.major.x = element_line(color = scodagrey2),
        panel.grid.minor.x = element_line(color = scodagrey2), 
        line = element_line(colour = scodagrey),
        legend.position = "bottom")
  
 
```


